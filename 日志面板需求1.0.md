# 日志面板需求 1.0（LogHUD PRD）

## 1. 产品概述
- **产品名称（暂定）**: LogHUD（科幻风悬浮日志面板）
- **一句话描述**: 一个可常驻屏幕右上角或任意位置的半透明、无边框、可调整大小的悬浮面板；实时接收多个 WebSocket 服务的 JSON Lines 数据，自动推断字段并按可配置模板高亮渲染，支持标签切换与综合聚合；提供「简模式」图标，一键将面板高度收起为 3 行。
- **目标用户**: 开发者、运维、数据分析师、产品/运营等需要观察实时事件流的人群。
- **核心价值**:
  - 多数据源聚合 + 可配置模板渲染，打造沉浸式「科幻终端」体验。
  - JSON Lines 友好的流式展示与弹性处理，轻量、稳健、可扩展。
  - 一键「简模式」3 行收起，随时把复杂信息变为微型 HUD。

---

## 2. 术语定义
- **JSON Lines/JSONL/NDJSON**: 每行一个独立 JSON 对象的文件/数据流格式。
- **频道（Channel）**: 以 URL path 区分的消息主题；同一路径的连接收到相同广播。
- **综合视图（Combined）**: 将多个已配置数据源的消息合并展示的默认标签页。
- **模板 DSL**: 用于描述每条 JSON 的渲染格式的轻量表达式语言。
- **模式推断（Schema Inference）**: 从最近 3–10 条 JSON 自动提取字段结构与类型，辅助生成模板。
- **简模式（Simple Mode）**: 一键收起高度，仅显示 3 行最新内容的紧凑展示形态。
 - **集群（Cluster）**: 多台服务端节点互联组成的逻辑整体，节点之间转发广播消息并保持去重一致性。
 - **节点（Node）**: 集群中的一台服务端实例，拥有唯一`nodeId`。
 - **消息封包（Message Envelope）**: 服务端注入的保留字段`_meta`，包含`id/ts/unixNs/originNodeId/channel/keyVersion/hmac`等用于去重、排序与校验的元信息。
 - **消息 ID（Message ID）**: 采用`UUIDv7`（时间有序 UUID），碰撞概率极低；用于跨节点去重与排序。
 - **时间戳（ts）**: UTC 时间；包含 `RFC3339` 字符串与 `unixNs` 两种形式，服务端在产生封包时注入。
 - **信任与加密（Trust & Crypto）**: 集群内节点通过 TLS 互联，消息封包使用 `HMAC-SHA256` 验签；可选对集群内转发的消息体使用 `AES-256-GCM` 二次加密（默认开启）。
 - **加入令牌（Join Token）**: 管理员签发的短期令牌，用于新节点加入集群时的认证与密钥分发。

---

## 3. 用户故事
- 我希望面板能长期显示在屏幕右上角，不挡住工作区，并保持半透明。
- 我希望添加多个 WebSocket 服务地址（可命名），默认看到综合视图；需要时切到单个源的标签页。
- 我希望应用能识别最近的 JSON 字段，自动生成初始模板，我再微调样式类型（如`primary/second/warning/error/notice/debug/normal`）、截断、顺序等。
- 我希望能把`.title`标记为`primary`（主题主色）、`.body.level`标记为`second`（次要信息）、`.body.content`截断为 100 字符，最后显示原始 JSON（可标记为`debug`）。
- 我希望能用 HTTP POST 向某频道推送一条 JSON，所有连接该频道的客户端都实时收到。
- 我希望设置透明度、背景图（拉伸/裁剪填充/平铺），打造「科幻终端」效果。
- 我希望随时点击一个图标，让面板收起为仅 3 行高度的简模式，再点恢复原状。
 - 我希望服务端可以横向扩展成集群，节点之间自动转发广播消息；客户端连接多台服务器并自动去重与按时间排序展示。
 - 我希望新增一台服务器加入集群时流程简单安全（令牌加入），且消息在集群内传输是加密并可校验来源的。

---

## 4. 范围界定
- 客户端：macOS 原生应用，使用 Swift（SwiftUI + AppKit 桥接）实现 UI/窗口/渲染/配置。
- 服务端：放在客户端工程的`server/`目录中，使用 Go 编写，可部署到 Railway；支持单机与集群模式（节点互联、加入、鉴权、加密转发）。
- 数据格式：接收端按 JSON Lines 处理；每条消息是一行 JSON。
- 频道：以 URL path 区分。`GET` 升级为 WebSocket；`POST` 同路径即广播到该频道所有客户端。

---

## 5. 功能需求

### 5.1 窗口与交互
- **无边框半透明悬浮窗**:
  - 无标题栏、无系统关闭/最小化/最大化按钮；鼠标悬停时浮现自定义关闭按钮。
  - 支持拖拽背景移动窗体；窗口可设置「始终置顶」（可跨桌面/Spaces）。
  - 默认吸附屏幕右上角，可记忆上次位置与尺寸。
  - 支持四边和四角区域的隐形拖拽调整大小（改变鼠标指针反馈）。
  - 背景支持毛玻璃/模糊（可选）与自定义透明度。
- **标签页**:
  - 默认存在「综合」标签，聚合显示所有已配置源的数据（按到达时间排序）。
  - 每个数据源一个标签页，标签可重命名、排序、关闭。
  - 标签显示未读计数与状态（连接中/已连接/断开）。
- **悬浮控制与操作**:
  - 鼠标进入面板：显示关闭按钮与设置入口；离开后渐隐。
  - 支持暂停/恢复滚动、清屏、快速复制一条消息原文。
- **键盘/快捷键（可选）**:
  - 全局召唤/隐藏面板（可选需要辅助权限）。
  - 切换标签、暂停/恢复、清屏等。
- **简模式（3 行）图标开关**:
  - 在面板右上角的工具区展示一个「简模式」图标（双箭头或压缩形象）。
  - 点击进入/退出简模式：
    - 进入后，窗口高度收起至仅能显示 3 行可见内容（不含标签与工具栏）；宽度不变。
    - 简模式下可水平/纵向滚动历史，但默认自动滚动到最新；提供「暂停自动滚动」按钮。
    - 简模式下允许改变窗口宽度；改变高度仅在退出简模式后生效（高度在简模式锁定）。
    - 简模式下显示最近 3 条消息；显示更多需滚动或退出简模式。
    - 简模式下在工具区显示累计未读计数（若暂停或滚动到历史）。
    - 切换标签时保持简模式状态（全局/每标签可选项，见设置）。
  - 状态持久化：退出与重启应用后保留上次简模式开/关状态与高度。
  - 交互一致性：
    - 进入简模式后再点击图标恢复为「之前的高度」。
    - 悬停 300ms 显示图标；离开淡出，避免视觉干扰。

### 5.2 数据接入与广播
- **WebSocket GET**:
  - 请求`GET /{channel}`升级为 WebSocket。频道名允许嵌套路径（例如：`/metrics`, `/events/app1`）。
- **HTTP POST 广播**:
  - `POST /{channel}` 以`application/json`或`text/plain`提交 JSON Raw Body，服务端将消息作为“一行 JSON”广播到该频道所有 WebSocket 客户端。
  - 非 JSON 或解析失败返回 400。
- **广播模式**:
  - 同频道内所有客户端都能收到任意一个客户端或 HTTP POST 推送的消息。
  - 不做持久化与重放（v1）；仅实时推送。
- **默认端口**: 服务器默认监听`8080`（Railway 读取`PORT`环境变量，若无则回退 8080）。

- **消息封包注入（服务端）**:
  - 服务端在收到原始 JSON 后，注入保留字段`_meta`，示例：
    ```json
    {
      "_meta": {
        "id": "018f1f2b-8a8b-7a42-bf90-8e2e7f9b0d11",
        "ts": "2025-09-08T12:34:56.789Z",
        "unixNs": 1757334896789000000,
        "originNodeId": "node-nyc-1",
        "channel": "/events/app1",
        "keyVersion": 1,
        "hmac": "base64(HMAC-SHA256(envelope_without_hmac))"
      },
      "title": "Order Created",
      "level": "info",
      "message": "... 原始业务字段 ..."
    }
    ```
  - `_meta`字段名保留，不与业务字段冲突；客户端用`_meta.id/_meta.ts`去重与排序。

### 5.3 多连接管理（客户端）
- 新增服务器：在设置中添加服务器机器（如`http://localhost:3388`用于开发；生产可为`https://log.example.com`）。
- 新增频道：只添加`channel`（URI path，如`/events/app1`），与服务器解耦；客户端将对“所有已启用服务器 × 所有已启用频道”建立连接。
- 支持多个服务器、多个频道；每条连接维持独立重连策略（指数退避，含最大间隔与抖动）。
- 汇总视图：合并所有连接的消息，依据`_meta.ts`排序并去重（按`_meta.id`）。
- 去重窗口：客户端维护 LRU 去重集合（最近 N 条，容量与时长可配置，默认容量 100k、时长 10 分钟）。
- 排序策略：先按`_meta.unixNs`升序，若相同则按`_meta.id`字典序；允许`±800ms`的重新排序缓冲。

### 5.4 JSON Lines 解析与模式推断
- 解析：按行读取，每行独立 JSON，失败行计入“错误计数”，可在 UI 提示“坏行”，用户可复制查看。
- 模式推断：在收到每源第 3～10 条时：
  - 采样近 N 条（N 默认 10，可配置），抽取字段路径（点语法）与类型（string/number/bool/null/object/array）。
  - 统计字段出现频率、值长度分布，产出“候选模板”与“字段树”。

### 5.5 模板 DSL（渲染表达式）
- **语法概述**:
  - 由若干段表达式组成，顺序渲染到一行内。一个段可加语义样式函数，如`primary(expr)`。
  - 变量取值使用“点语法 JSONPath 的简化版”：`${.field}`、`${.body.level}`、`${.items[0].title}`。
  - 特殊变量：`${$_}`为原始 JSON 字符串。
  - 常量：支持直接使用下述常量标记（无需`$\{\}`包装）：
    - `$TIME`：时间，不含日期，格式`HH:MM:SS`；基于消息`_meta.ts`并按本地时区显示。
    - `$DATE`：日期，不含时间，格式`YYYY-MM-DD`；基于消息`_meta.ts`并按本地时区显示。
    - `$DATE_TIME`：日期+时间，格式`YYYY-MM-DD HH:MM:SS`；基于消息`_meta.ts`并按本地时区显示。
    - `$UUID`：消息 ID（取自`_meta.id`，推荐 UUIDv7）。
    - `$UUID_LAST6`：消息 ID 的后 6 位（去除连字符后取末 6 位）。
- **函数与操作**:
  - 语义样式函数：`primary(x)`, `second(x)`, `warning(x)`, `error(x)`, `notice(x)`, `debug(x)`, `normal(x)`。
  - 主题映射规则：上述函数不直接指定具体颜色，颜色由当前选择的「颜色主题」统一映射；用户仅设置样式类型与选择主题，不配置具体色值。切换主题后，模板无需修改即可呈现新配色。
  - 文本函数：
    - `max(str, length, extra="..")`：超过`length`截断并追加`extra`。
    - `default(x, fallback)`：空/缺失时使用`fallback`。
    - `join(arr, sep=",")`：数组连接为字符串。
    - `fmt(format, ...args)`：格式化（v1.1 可选）。
  - 运算（可选）：`+`拼接（数字自动转字符串），`??`空合并。
- **示例**:
  - `primary(${.title}):second(${.body.level}) normal(max(${.body.content},100,"...")) debug(${$_})`
  - `second($DATE_TIME) primary(${.title}) normal($UUID_LAST6)`
- **错误容忍**:
  - 缺失字段渲染为空字符串；类型不合时使用`toString`策略。
- **模板存储**:
  - 每个标签页可绑定一个模板；综合视图可有独立模板（包含“来源徽记”占位符如`${.source.name}`）。
- **自动模板生成**:
  - 基于最近 10 条的字段频率与平均长度：
    - 选择 Top K（如 3～5）个信息量最大字段，生成初始模板。
    - 为超长字段自动包裹`max(…, 100, "...")`。
    - 为可能作为“标题/级别/正文”的字段提供推荐（命中`title`, `level`, `message/content/body`等关键词）。
  - UI 提供“建议模板 → 一键应用/编辑”。

### 5.6 过滤、搜索与格式化（v1.1 可选）
- 关键字过滤、字段条件过滤（如`.level in ["warn","error"]`）。
- 高亮匹配词。
- 导出当前可视数据为`.jsonl`或`.txt`。

### 5.7 设置项
- **外观**:
  - 透明度（0–100%）。
  - 背景图：选择文件；填充模式：拉伸、裁剪填充（cover）、平铺（repeat）；（可选）等比适配（contain）。
  - 颜色主题：下拉选择；预设暗色主题至少 8 种，提供即时预览；切换主题后全局生效且模板无需修改。
    - 预设示例：Dracula、One Dark（默认）、Nord、Monokai、Gruvbox Dark、Solarized Dark、Material Ocean、Night Owl、Tomorrow Night、Cobalt 2。
    - 仅可选择主题，不支持自定义色值（v1.0）。
  - 字体与字号：可选择系统可用字体（优先等宽字体，如 SF Mono/JetBrains Mono）；字号范围 10–24，步进 1；所见即所得预览。
- **行为**:
  - 吸附屏幕边缘、是否跨桌面置顶。
  - 最大保留行数（滚动缓冲区）与内存上限。
  - 自动重连策略参数（初始/最大间隔、抖动）。
  - 简模式选项：
    - 进入标签是否继承全局简模式；
    - 简模式固定可见行数（默认 3，可设 2–5）；
    - 简模式下是否显示未读徽标与数量；
    - 退出简模式时是否恢复历史高度。
- **数据源管理**:
  - 服务器机器：增删改查、导入导出；支持别名与标签。
  - 频道：增删改查；与服务器分离管理；可批量启用/禁用。
- **模板管理**:
  - 每源/综合模板编辑、预览、导入导出。
- **隐私与安全**:
  - 是否接受本机 POST；来源 IP 白名单；令牌校验（v1.1）。

### 5.9 文件 Watcher（采集器）
- **目标**：在本机或远端以`tail -f`方式持续读取 JSON Lines 日志文件，可靠处理日志轮转，并将新追加的行作为 JSON 推送到服务端指定的`/<channel>`。
- **行为**：
  - 初次启动：从上次已发送的偏移继续（若存在状态文件）；否则从文件末尾开始（可配置从开头）。
  - 读取：逐行读取并解析为 JSON（单行），失败行可选择跳过或转发为`{"_meta":{...},"_error":"invalid json","raw":"..."}`（可配置）。
  - 发送：按追加顺序通过 HTTP `POST http(s)://<server>/<channel>` 推送；失败自动重试（指数退避，限最大间隔）。
  - 去重与断点：将文件标识（inode/文件ID + 路径）与偏移量持久化到状态文件；避免重启后重复发送。
  - 轮转处理：识别文件 inode 变化与新文件创建，旧文件读到 EOF 后切换到新文件；保证不丢不重。
  - 多路：支持同时监听多个文件 → 多个 channel 的映射；每个文件独立维护状态。
- **配置项（示例）**：
  - `watcher.files[]`：`path`, `channel`, `fromBeginning?`, `maxLineBytes`, `jsonStrict?`, `skipInvalid?`
  - `watcher.sender`：`serverBaseURL`（如开发`http://localhost:3388`）、`concurrency`、`retry`参数。
  - `watcher.stateDir`：状态文件目录（默认：`~/.futurepanel/watcher`）。
- **运行**：提供二进制与 systemd 服务安装脚本`future_watcher`。
### 5.8 集群与消息一致性（服务端）
- **节点互联**:
  - 节点之间通过`wss://<host>/_cluster/stream`建立持久连接（双向可选，至少单向连通）；传输使用 TLS。
  - 连接建立时通过`Authorization: Bearer <nodeToken>`进行认证；`nodeToken`为加入流程颁发的短期签名令牌。
- **消息转发**:
  - 本节点收到的每条消息在注入`_meta`后，除了广播给本地客户端，还会作为“集群事件”转发给其他节点；其他节点收到后按`_meta.id`幂等处理并再广播给其本地客户端。
- **加密与签名**:
  - 传输层：TLS（HTTPS/WSS）。
  - 消息级认证：对`_meta + payload`计算`HMAC-SHA256`，放入`_meta.hmac`；集群内共享`clusterKey`与`keyVersion`。
  - 消息级加密（可选，默认开启）：对`payload`使用`AES-256-GCM`加密，`nonce`可由`_meta.id`与`keyVersion`派生；仅在节点间传输为密文，广播到客户端前在本地节点解密。
- **加入机制**:
  - 管理员在任意现有节点生成一次性`joinToken`（含过期时间与目标权限）。
  - 新节点调用`POST /_cluster/join`提交自身`nodeId/publicKey/address`与`joinToken`，通过后获得：
    - 当前成员列表（`nodeId/address/publicKey`）。
    - 集群对称密钥`clusterKey`与`keyVersion`（使用新节点`publicKey`加密回传）。
  - 加入后，新节点按成员列表主动连接若干对等节点（可配置最小拓扑度，如 3）。
- **成员维护**:
  - 心跳与健康：`GET /_cluster/healthz`或在 stream 内定期 ping/pong；超时剔除并广播变更。
  - 成员列表定期 gossip 同步；节点启动时也会拉取一次`/_cluster/members`。

---

## 6. 非功能性需求
- **兼容性**: macOS 12+（Monterey）及以上；Apple Silicon 与 Intel。
- **性能**:
  - 单源每秒 200 条以内平滑渲染无卡顿（基础版指标）。
  - 消息大小上限默认 1MB（可配置，超限丢弃并提示）。
  - UI 虚拟列表与批量渲染（按帧合批）。
- **稳定性**:
  - 网络抖动自动重连；异常断开不崩溃；坏行隔离。
- **安全**:
  - `wss://` 支持；HTTP POST 需可选令牌校验与速率限制（v1.1）。
- **隐私**:
  - 本地仅存设置与模板，不上传任何消息内容（除非用户导出）。
- **可访问性**:
  - 高对比度模式、动态字体（v1.1）。

---

## 7. 架构与技术方案

### 7.1 客户端（Swift）
- **框架**: SwiftUI + AppKit（通过 `NSWindow`/`NSPanel` 自定义无边框悬浮窗）
  - `NSWindow.StyleMask.borderless`，`titleVisibility = .hidden`，`isMovableByWindowBackground = true`。
  - `level = .floating`（可选 `.statusBar`），`collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]`。
  - 通过 `NSTrackingArea` 捕捉鼠标进入/离开/边缘拖拽区域。
  - 背景使用 `NSVisualEffectView` 或自绘含透明度与背景图。
- **数据层**:
  - 每数据源一个 `WebSocketClient`：重连、心跳、背压处理。
  - `MessageBus` 聚合到综合视图；按到达时间排序。
- **渲染层**:
  - `TemplateEngine` 解析 DSL 与计算语义样式，并按当前主题映射为具体颜色；行级 Diff/VList 优化滚动。
- **推断器**:
  - `SchemaInference`：抽样分析字段与类型产出「字段树 + 候选模板」。
- **简模式实现**:
  - 记录「普通高度」与「简模式高度（行高*3 + 内边距）」；切换时动画过渡。
  - 简模式下锁定高度，滚动容器限制到可见 3 行；工具区显示徽标与未读计数。

### 7.2 服务端（Go，内置于客户端工程）
- **目录结构**:
  - `server/`
    - `main.go`
    - `go.mod` / `go.sum`
    - `handlers/…`
    - `hub/…`（每频道广播 Hub）
    - `Procfile`（Railway）
    - `README.md`
- **依赖建议**:
  - 路由：`chi` 或 `gin`。
  - WebSocket：`nhooyr.io/websocket`。
- **路由与协议**:
  - `GET "/{channel}"`：升级 WebSocket。频道名允许嵌套路径（如`/events/app1`）。
  - `POST "/{channel}"`：Body 为 JSON 文本（原样转发、单行化）。
  - 健康检查：`GET "/healthz"` → 200, `{ "ok": true }`。
 - **集群路由**:
   - `POST "/_cluster/join"`：新节点携带`joinToken`申请加入；返回成员列表与密钥材料。
   - `GET  "/_cluster/members"`：返回当前成员列表。
   - `GET  "/_cluster/healthz"`：集群健康（可与`/healthz`合并）。
   - `GET  "/_cluster/stream"`：升级为 WebSocket，双向节点事件流（认证：Bearer nodeToken）。
- **广播设计**:
  - `map[channel]Hub`；`Hub` 维护订阅者集合与消息通道。
  - 写入时限与缓冲队列；慢客户端丢弃或断开策略（配置化）。
 - **集群转发设计**:
   - 本地收到消息→注入`_meta`（若上游已注入则复用）→写入本地 Hub→并行推送到所有对等节点（排除来源节点）。
   - 幂等：按`_meta.id`去重，节点侧维护 LRU 近期 ID 集合（容量与 TTL 可配）。
   - 安全：校验`_meta.hmac`与`keyVersion`，不通过则拒收并告警。
- **部署（Railway）**:
  - 读取 `PORT` 环境变量；缺省回落到 `8080`。
  - 提供部署说明与环境变量示例。

### 7.3 Watcher（Go，独立目录 `watcher/`）
- **目录与组件**：
  - `watcher/`
    - `main.go`：入口；解析 CLI；协调 reader/sender/state。
    - `reader/`：文件 tail 读取（支持 inode 变更与轮转识别）。
    - `sender/`：批量或单条 POST；重试与幂等。
    - `state/`：状态管理，持久化偏移与文件标识。
    - `config/`：解析`watcher.yaml/json`。
    - `systemd/`：包含示例`future-watcher.service`模板（由安装脚本写入）。
- **CLI 参数（示例）**：
  - `--config /etc/futurepanel/watcher.yaml`
  - `--server http://localhost:3388`（可覆盖配置文件）
  - `--concurrency 4`
  - `--state-dir ~/.futurepanel/watcher`
  - `--from-beginning`（可选，默认从文件末尾开始）
  - `--token <BearerToken>`（可选）
- **关键设计**：
  - 识别“同路径新文件”（inode 变化）→ 处理旧文件到 EOF → 切换新文件；
  - 偏移恢复：重启后从状态文件读取偏移继续；
  - 去重防重复：基于（文件ID+偏移）作为幂等键，不重新发送已确认的偏移；
  - 背压与限速：支持发送并发和最大在途请求数限制；
  - 安全：支持 HTTPS 与可选 Bearer Token；
  - 可靠：本地队列（可选）在断网时暂存，网络恢复后补发。
  - 轮转检测：通过 inode 与文件大小回退识别；老文件读完后再切换新文件，避免遗漏尾部数据。
 - **systemd 服务**：提供安装脚本`future_watcher`，创建服务`future-watcher.service`，从配置文件启动并托管日志。
   - 安装脚本内容（示意）：
```bash
#!/usr/bin/env bash
set -euo pipefail

NAME="future-watcher"
BIN_PATH="/usr/local/bin/future-watcher"
CONF_DIR="/etc/futurepanel"
CONF_FILE="$CONF_DIR/watcher.yaml"
STATE_DIR="/var/lib/futurepanel/watcher"
SERVICE_FILE="/etc/systemd/system/${NAME}.service"

command -v systemctl >/dev/null 2>&1 || { echo >&2 "systemctl required"; exit 1; }

if [[ ! -x "$BIN_PATH" ]]; then
  echo "error: $BIN_PATH not found or not executable" >&2
  exit 1
fi

sudo mkdir -p "$CONF_DIR" "$STATE_DIR"
sudo chown -R "$USER":"$USER" "$CONF_DIR" "$STATE_DIR"

if [[ ! -f "$CONF_FILE" ]]; then
  cat <<EOF | sudo tee "$CONF_FILE" >/dev/null
serverBaseURL: "http://localhost:3388"
stateDir: "$STATE_DIR"
files:
  - path: "/var/log/app/events.jsonl"
    channel: "/events/app1"
    fromBeginning: false
EOF
fi

cat <<EOF | sudo tee "$SERVICE_FILE" >/dev/null
[Unit]
Description=FuturePanel Watcher Service
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=$BIN_PATH --config $CONF_FILE
Restart=always
RestartSec=3
User=$USER
Group=$USER
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable "$NAME"
echo "Installed. Start with: sudo systemctl start $NAME && sudo systemctl status $NAME -l"
```

---

## 8. 数据结构与存储

### 8.1 应用配置（本地）
- 路径：`~/Library/Application Support/LogHUD/config.json`
- 结构示例：
```json
{
  "window": {
    "x": 1400,
    "y": 20,
    "width": 420,
    "height": 600,
    "alwaysOnTop": true,
    "opacity": 0.85,
    "backgroundImage": "/path/to/bg.png",
    "backgroundMode": "cover", 
    "simpleMode": false,
    "simpleModeVisibleLines": 3
  },
  "appearance": {
    "theme": "One Dark",
    "fontFamily": "JetBrains Mono",
    "fontSize": 13
  },
  "servers": [
    { "id": "dev-local", "name": "Local Dev", "baseUrl": "http://localhost:3388", "enabled": true },
    { "id": "prod-1", "name": "Prod A", "baseUrl": "https://log-a.example.com", "enabled": true },
    { "id": "prod-2", "name": "Prod B", "baseUrl": "https://log-b.example.com", "enabled": false }
  ],
  "channels": [
    { "id": "ch-events", "path": "/events/app1", "enabled": true, "template": "primary(${.title}) second(${.level}) normal(max(${.message},120))" },
    { "id": "ch-metrics", "path": "/metrics", "enabled": false }
  ],
  "aggregator": {
    "dedup": { "enabled": true, "capacity": 100000, "ttlSeconds": 600 },
    "ordering": { "field": "_meta.unixNs", "toleranceMs": 800 }
  },
  "combined": {
    "template": "[${._meta.channel}] primary(${.title}) - second(${.level}) normal(max(${.message},120))"
  },
  "limits": {
    "maxLines": 5000,
    "maxMessageBytes": 1048576
  },
  "inference": {
    "sampleSize": 10
  }
}
```

### 8.2 服务端配置（本地）
- 路径：`server/config.json`（建议）
- 结构示例：
```json
{
  "nodeId": "node-nyc-1",
  "publicUrl": "https://log-a.example.com",
  "cluster": {
    "enabled": true,
    "peers": ["https://log-b.example.com", "https://log-c.example.com"],
    "keyVersion": 1,
    "clusterKey": "base64(aes256_key)",
    "acceptJoin": true
  }
}
```

### 8.3 Watcher 状态文件（本地）
- 路径：默认 `~/.futurepanel/watcher/state.json`（可分片为每文件一个状态`<hash>.json`）。
- 结构示例：
```json
{
  "version": 1,
  "files": [
    {
      "path": "/var/log/app/events.jsonl",
      "fileId": "dev-inode-123456" ,
      "offset": 987654321,
      "lastSentAt": "2025-09-08T12:34:56Z",
      "channel": "/events/app1",
      "serverBaseURL": "http://localhost:3388"
    }
  ]
}
```
---

## 9. API 设计（服务端）
- **连接 WebSocket**:
  - 请求：`GET ws://<host>:<port>/<channel>`
  - 升级成功：开始接收广播消息（逐条为一行 JSON 字符串）。
- **推送消息**:
  - 请求：`POST http://<host>:<port>/<channel>`
  - Header：`Content-Type: application/json`（或`text/plain`，内容是合法 JSON）
  - Body：一条 JSON 对象文本（服务端发给订阅者时保证单行）。
  - 响应：`202 Accepted` 或 `200 OK` + `{ "ok": true }`。
- **错误响应**：
  - `400` 非法 JSON；`413` 过大；`429` 速率限制（如启用）；`500` 内部错误。

### 9.1 Watcher 上报（客户端 → 服务端）
- **发送协议**：HTTP `POST http(s)://<server>/<channel>`，Header：`Content-Type: application/json`
- **请求体**：单条 JSON 对象。服务端注入`_meta`后广播。
- **幂等性**：若上报端重复发送相同行（例如因重试），服务端凭`_meta.id`或内容指纹（可选）去重（建议由服务端统一注入`_meta.id`）。

- **集群 API**：
  - `POST /_cluster/join`：请求体包含`nodeId/publicKey/address/joinToken`；返回`members[]`、`clusterKey`（用`publicKey`加密）、`keyVersion`。
  - `GET  /_cluster/members`：返回`{ members: [{ nodeId, address, publicKey, lastSeen }] }`。
  - `GET  /_cluster/stream`（WS）：节点事件流，帧类型包括`Msg`, `Ack`, `Ping`, `Members`；连接时需`Authorization: Bearer <nodeToken>`。

 - **Watcher API**（与普通推送一致）：
   - `POST "/{channel}"`：Body 为 JSON 文本（单行），由 Watcher 发送。

---

## 10. 边界与限制
- **消息顺序**：单频道内按服务端收到的顺序转发；综合视图按全局到达时间合并（跨频道无全局顺序保证）。
- **持久化**：v1 不做消息持久化与重放。
- **背压**：慢客户端可能被断开或丢弃部分消息（可配置策略）。
- **大小限制**：默认 1MB；超限拒收并告警。
- **简模式**：仅锁定高度与可见行数，不改变模板渲染内容；未读计数仅在暂停或非底部时累加。
 - **时钟与重排**：不同节点与客户端存在时钟偏差；客户端采用`±800ms`的重排缓冲与稳定排序，可能导致极端情况下与真实到达存在轻微出入。
 - **成员一致性**：成员列表采用最终一致，同步存在传播延迟；短时网络分区不影响消息幂等性（凭`_meta.id`去重）。

---

## 11. 版本规划
- **v1.0（Must）**:
  - 无边框半透明窗、右上角悬浮、可调整大小/移动、悬停显隐控制。
  - 多源管理、标签页与默认综合视图。
  - WebSocket 接入；POST 广播到频道；默认端口 8080。
  - JSON Lines 解析；模式推断（3–10 条）；模板 DSL + 语义样式（主题映射）/截断函数；本地配置持久化。
  - 颜色主题选择、字体与字号选择；
  - 背景图与填充模式（拉伸/裁剪/平铺）；
  - 一键简模式（3 行）图标开关与状态持久化。
- **v1.1（Should/Could）**:
  - 集群模式（基础）：节点互联、HMAC 验签、AES-GCM 加密、加入令牌、成员列表同步；客户端多服务器订阅、去重与排序。
  - 过滤/搜索、令牌鉴权、防刷、更多语义样式函数与格式化、快捷键、导出、等比适配（contain）。
  - 文件 Watcher（采集器）：tail 读取、轮转处理、状态持久化、可靠投递与 systemd 安装脚本。

---

## 12. 验收标准（关键用例）
- 添加两个不同服务器与频道后，「综合」标签实时显示两路消息，顺序与到达时间一致。
- 对一条包含`title/level/content`的消息，应用模板后样式类型映射到当前主题颜色，且截断效果符合预期。
- 背景图设置为「平铺」时，窗口尺寸变化仍保持覆盖与对齐规则。
- 鼠标靠近四边八角可调整大小；悬停 300ms 后出现关闭与工具区图标。
- 点击「简模式」图标后，窗口高度动画收起至 3 行可见内容；再次点击恢复为之前高度。
- 简模式中新消息到来自动滚动到底部；暂停后未读计数正确显示。
- `POST /events/app1`发送一条 JSON，所有连接`GET /events/app1`的客户端均能在 <200ms 内收到（同地域网络）。
 - 在设置中切换不同颜色主题后，所有模板渲染颜色随主题变化且模板本身无需修改；预览与实际一致并持久化。
 - 在设置中选择字体与字号后，面板所有文本即时更新并在重启后保持。
 - 集群：向任一节点`POST /events/app1`，其他节点的客户端能在 200ms 内收到；网络分区恢复后无重复消息（按`_meta.id`去重）。
 - 集群：新节点携带`joinToken`加入后，能在 1 秒内收到成员列表并建立到至少 2 个对等节点的 stream；消息验证（HMAC）失败时拒收并记录。
 - 客户端：配置三台服务器（含`http://localhost:3388`）与两个频道，综合视图能正确去重并按`_meta.unixNs`排序显示。
 - Watcher：首次启动从文件末尾开始，仅发送新增行；配置`fromBeginning=true`时从头发送。
 - Watcher：日志轮转时无丢无重；重启后不会重复发送已确认偏移的内容。
 - Watcher：同时监听两个文件并发送到不同 channel，服务端均正确收到且格式合法。

---

## 13. 测试要点
- JSON 解析健壮性（坏行、空行、超长）。
- 重连与断网恢复；高频小包与低频大包。
- 模板边界：缺失字段、非字符串、嵌套数组。
- 多显示器与缩放下的拖拽与吸附；透明度与背景图呈现。
- 大量行时滚动性能与内存占用（虚拟化）。
- 简模式切换时的高度锁定、未读计数、自动滚动与动画。

---

## 14. 风险与应对
- 高吞吐导致 UI 卡顿 → 虚拟列表、合批渲染、行上限裁剪。
- 非法/恶意 POST → 速率限制、大小限制、可选 token。
- 模板 DSL 复杂度 → v1 保持最小可用集合，逐步扩展。
- 边缘拖拽与无边框窗口交互易误触 → 增加热区与指针反馈；提供设置项关闭。

---

## 15. 开发里程碑（建议）
- 第 1 周：窗口外观与交互雏形（无边框/半透明/移动/缩放/标签框架）。
- 第 2 周：WebSocket 客户端、多源管理、综合视图聚合。
- 第 3 周：服务端 Go 实现（频道广播/POST 推送/部署到 Railway），默认端口 8080。
- 第 4 周：模板引擎与模式推断、模板编辑器与建议模板。
- 第 5 周：背景图与填充模式、设置页与配置存储、简模式实现与动画调校。
- 第 6 周：测试与验收、文档与打包、v1.1 功能排期。

---

### 附：模板 DSL 快速参考
- 取值：`${.a.b}`, `${.list[0].name}`, `${$_}`
- 语义样式：`primary(x)`, `second(x)`, `warning(x)`, `error(x)`, `notice(x)`, `debug(x)`, `normal(x)`（颜色由主题决定）
- 文本：`max(str,len,"..")`, `default(x,"-")`, `join(arr,",")`
- 常量：`$TIME`（HH:MM:SS）、`$DATE`（YYYY-MM-DD）、`$DATE_TIME`（YYYY-MM-DD HH:MM:SS）、`$UUID`、`$UUID_LAST6`
- 组合示例：
```text
[${._meta.channel}] second($DATE_TIME) primary(${.title})  normal(max(${.body.content}, 100, "..."))  debug($UUID_LAST6)
```
